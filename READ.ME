
A)AIMS AND GOALS OF THE PROJECT

B)PREREQUISITES/CONTENTS:

1a).DEVELOPMENT ENVIRONMENTAL SETUP
 
1b.TECH STACK :
IDEs: VSCode, Vim, Jupyter Notebook, Notepad++, Angular, PyCharm
2)MEDIA:
-Diagrams (Flow charts)

3).CODE:

4).DEBBUGGING:
-Debugging Technique.

5).COMMON PITFALLS/PROBLEMS:



A)AIMS AND GOALS OF THE PROJECT:

A)AIMS AND GOALS OF THE PROJECT
Food is an important matter for mankind, weather the issue is that,people as creates of choice have the following tates or rights :
' people eat to survive'  or ' people love to eat' or 'people eat to survive' irrespective of the flavor of
the food' ,while for some people the, search for ' different flavours,
recipes and foods',which occupies most of their time as hobbies or 'professional interests'.
This App  explores , all the different interests amongst mankind as expressed above, 
via the creation of a Recipe Food Search App using Vue.js , and the Edamam Recipe API.
The app allows users to input ingredients, and find related recipes. 
The goal is to build a simple yet powerful tool for meal planning, integrating API data 
and searched/discovered recipes to make eating of food not just to satisfy the ,
hunger pangs , but to make eating a welcoming, relaxing experience ,which 
humans can look forward to!

B)PREREQUISITES/CONTENTS:

1a).DEVELOPMENT ENVIRONMENTAL SETUP
 
1b.TECH STACK :
IDEs: VSCode, Vim, Jupyter Notebook, Notepad++, Angular, PyCharm
2)MEDIA:
-Diagrams (Flow charts)

3).CODE:

4).DEBBUGGING:
-Debugging Technique.

5).COMMON PITFALLS/PROBLEMS:
6.)CONCLUSION






1a. Developmental Setup

#### Required Tools and Libraries

- **Programming Language**: Python
- **Framework**: Flask (for web application)
- **Database**: SQLite or PostgreSQL (for storing recipes)
- **JSON Handling**: `json` library (built-in)
- **Environment Management**: `virtualenv` or `conda`
- **Docker**: For containerization
- **GitHub Actions**: For CI/CD

#### Installation Commands

```bash
# Create a virtual environment
python -m venv venv
source venv/bin/activate  # On Windows use `venv\Scripts\activate`

# Install Flask and other dependencies
pip install Flask requests

# Install SQLite (if not available)
sudo apt-get install sqlite3

# Install Docker (follow Docker installation documentation)
```

### 2. Source Code

Here’s a simple Flask application for a Recipe Food Search App.

#### Directory Structure

```
recipe_food_search/
│
├── app.py
├── requirements.txt
├── Dockerfile
└── .github/
    └── workflows/
        └── ci.yml
```

#### `app.py`

```python
from flask import Flask, jsonify, request
import sqlite3
import json

app = Flask(__name__)

# Initialize SQLite database
def init_db():
    conn = sqlite3.connect('recipes.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS recipes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            ingredients TEXT NOT NULL,
            instructions TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

@app.route('/recipes', methods=['POST'])
def add_recipe():
    data = request.json
    name = data['name']
    ingredients = json.dumps(data['ingredients'])
    instructions = data['instructions']
    
    conn = sqlite3.connect('recipes.db')
    cursor = conn.cursor()
    cursor.execute('INSERT INTO recipes (name, ingredients, instructions) VALUES (?, ?, ?)',
                   (name, ingredients, instructions))
    conn.commit()
    conn.close()
    
    return jsonify({"message": "Recipe added"}), 201

@app.route('/recipes', methods=['GET'])
def get_recipes():
    conn = sqlite3.connect('recipes.db')
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM recipes')
    rows = cursor.fetchall()
    conn.close()
    
    recipes = [{"id": row[0], "name": row[1], "ingredients": json.loads(row[2]), "instructions": row[3]} for row in rows]
    return jsonify(recipes)

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
```

#### `requirements.txt`

```
Flask
requests
```

### 3. Diagram of the Tech Stack


1)User Friendly , and attractive UI(Boothstrap) --->
2)Backend --->.
3)API --->. 
4)Load Balancer --->. 
5)Message Queue(RabbitMQ)---> 
6. Database --->. 
7.Aparche Spark--->. 
8. Debugging/Error Handling/ Postman API endpoint or cURL.--->

```
+--------------------+
|    User Interface   |
|      (Frontend)     |
+--------------------+
           |
           v
+--------------------+
|      Flask API      |
|     (Backend)       |
+--------------------+
           |
           v
+--------------------+
|     SQLite DB       |
|   (Data Storage)    |
+--------------------+
```




3).CODE:


1a. Implementing Authentication and Authorization (User Sign-In)

**Step 1: Set Up User Model**

First, create a user model for MongoDB.

**`models/User.js`**

```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // Store hashed passwords
});

module.exports = mongoose.model('User', userSchema);
```

**Step 2: Hash Passwords**

Use `bcrypt` to hash passwords before saving them.

```bash
npm install bcrypt
```

**User Registration Example:**

```javascript
const bcrypt = require('bcrypt');
const User = require('./models/User');

async function registerUser(username, password) {
  const hashedPassword = await bcrypt.hash(password, 10);
  const user = new User({ username, password: hashedPassword });
  await user.save();
}
```

### 1b. Authentication Using JWT

**Step 1: Install JWT Library**

```bash
npm install jsonwebtoken
```

**Step 2: Generate JWT on Login**

```javascript
const jwt = require('jsonwebtoken');

async function loginUser(username, password) {
  const user = await User.findOne({ username });
  if (!user) throw new Error('User not found');

  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) throw new Error('Invalid password');

  const token = jwt.sign({ id: user._id }, 'your_jwt_secret', { expiresIn: '1h' });
  return token;
}
```

**Step 3: Middleware for Protected Routes**

```javascript
function authenticateToken(req, res, next) {
  const token = req.headers['authorization']?.split(' ')[1];
  if (!token) return res.sendStatus(401);

  jwt.verify(token, 'your_jwt_secret', (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
}
```

### 2. Using RabbitMQ for Recipe Notifications

**Step 1: Install RabbitMQ Library**

```bash
npm install amqplib
```

**Step 2: Set Up RabbitMQ Producer**

```javascript
const amqp = require('amqplib');

async function sendNotification(message) {
  const connection = await amqp.connect('amqp://localhost');
  const channel = await connection.createChannel();
  const queue = 'recipeNotifications';

  await channel.assertQueue(queue);
  channel.sendToQueue(queue, Buffer.from(message));
  console.log("Notification sent:", message);

  setTimeout(() => {
    connection.close();
  }, 500);
}
```

**Step 3: Set Up RabbitMQ Consumer**

```javascript
async function receiveNotifications() {
  const connection = await amqp.connect('amqp://localhost');
  const channel = await connection.createChannel();
  const queue = 'recipeNotifications';

  await channel.assertQueue(queue);
  channel.consume(queue, (msg) => {
    console.log("Received notification:", msg.content.toString());
    channel.ack(msg);
  });
}
```

### 3. Integrating MongoDB to Store User Saved Recipes

**Step 1: Create Recipe Model**

**`models/Recipe.js`**

```javascript
const mongoose = require('mongoose');

const recipeSchema = new mongoose.Schema({
  title: { type: String, required: true },
  ingredients: [String],
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
});

module.exports = mongoose.model('Recipe', recipeSchema);
```

**Step 2: Save User Recipes**

```javascript
const Recipe = require('./models/Recipe');

async function saveRecipe(userId, recipeData) {
  const recipe = new Recipe({ ...recipeData, userId });
  await recipe.save();
}
```

### 4. Using Apache Spark for Recipes

To use Apache Spark, you typically need to set up a Spark environment. Below is a simple example of using PySpark to analyze recipes.

**Python Example with PySpark:**

```python
from pyspark.sql import SparkSession

# Initialize Spark session
spark = SparkSession.builder.appName("RecipeAnalysis").getOrCreate()

# Load recipe data (assuming it's in JSON format)
df = spark.read.json("path/to/recipes.json")

# Show the data
df.show()

# Example Analysis: Count recipes by cuisine
df.groupBy("cuisine").count().show()

# Stop the Spark session
spark.stop()
```

### 5. Postman and cURL API Endpoint Debugging

#### Postman Example

1. **GET User Login**:
   - Method: POST
   - URL: `http://localhost:5000/api/login`
   - Body (JSON):
     ```json
     {
       "username": "testuser",
       "password": "testpass"
     }
     ```

2. **GET Recipes**:
   - Method: GET
   - URL: `http://localhost:5000/api/recipes`
   - Headers: `Authorization: Bearer <your_token>`

#### cURL Example

**Login Request**:

```bash
curl -X POST http://localhost:5000/api/login \
-H "Content-Type: application/json" \
-d '{"username": "testuser", "password": "testpass"}'
```

**Get Recipes**:

```bash
curl -X GET http://localhost:5000/api/recipes \
-H "Authorization: Bearer <your_token>"
'''

SECURITY :

A.Implementing security measures in a web application using
Helmet.js for the frontend, Passport.js for the backend, 
-
B.API PROTECTION :

i.input sanitation and validation,
ii.best practices for securing JWTs, 
and 
iii.rate limiting to prevent brute force attacks.

 1. Security

 a. Helmet.js for Frontend Security

**Installing Helmet.js:**

```bash
npm install helmet
```

**Using Helmet.js in an Express App:**

```javascript
const express = require('express');
const helmet = require('helmet');

const app = express();

// Use Helmet to secure HTTP headers
app.use(helmet());

//  our routes here
app.get('/', (req, res) => {
  res.send('Hello, secure world!');
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

 b. Passport.js for Backend Authentication

**Installing Passport.js and Necessary Strategies:**

```bash
npm install passport passport-local express-session
```

**Setting Up Passport.js for Local Authentication:**

```javascript
const express = require('express');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const session = require('express-session');
const bcrypt = require('bcrypt');
const User = require('./models/User'); // Your User model

const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(session({ secret: 'your_secret', resave: false, saveUninitialized: true }));
app.use(passport.initialize());
app.use(passport.session());

// Configure passport-local strategy
passport.use(new LocalStrategy(
  async (username, password, done) => {
    const user = await User.findOne({ username });
    if (!user) return done(null, false, { message: 'Incorrect username.' });
    const match = await bcrypt.compare(password, user.password);
    if (!match) return done(null, false, { message: 'Incorrect password.' });
    return done(null, user);
  }
));

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  const user = await User.findById(id);
  done(null, user);
});

// Login route
app.post('/login', passport.authenticate('local', {
  successRedirect: '/',
  failureRedirect: '/login',
}));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

- API SECURITY
 1. Input Sanitation to Prevent Injection Attacks

**Using the `express-validator` Library:**

**Installing express-validator:**

```bash
npm install express-validator
```

**Sanitizing Input:**

```javascript
const { body, validationResult } = require('express-validator');

app.post('/submit', [
  body('username').trim().escape(), // Sanitize username
  body('email').isEmail().normalizeEmail(), // Sanitize email
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  // Process sanitized data
});
```

2. Input Validation

**Validating Input with express-validator:**

```javascript
app.post('/register', [
  body('username').notEmpty().withMessage('Username is required').isLength({ min: 3 }).withMessage('Username must be at least 3 characters long'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters long'),
  body('email').isEmail().withMessage('Invalid email address'),
], (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  // Process validated data
});
```

3. Best Practices for Securing JWTs

### Best Practices:

1. **Use Strong Secrets**: Ensure our JWT secret is long and random.
2. **Set Expiration**: Always set an expiration time for our tokens.
3. **Use HTTPS**: Always serve our application over HTTPS.
4. **Store Tokens Securely**: Use HttpOnly cookies or secure storage mechanisms.
5. **Verify Tokens on Each Request**: Always validate the token on every request.

- Code for Creating a JWT:**

```javascript
const jwt = require('jsonwebtoken');

const createToken = (user) => {
  return jwt.sign({ id: user._id }, 'your_jwt_secret', { expiresIn: '1h' });
};

// Example of using the token
app.post('/login', async (req, res) => {
  // Assume user authentication is done
  const token = createToken(user);
  res.cookie('token', token, { httpOnly: true }); // Securely store the token
  res.json({ message: 'Logged in successfully', token });
});
```

## 5. Rate Limiting to Prevent Brute Force Attacks

**Using the `express-rate-limit` Library:**

**Installing express-rate-limit:**

```bash
npm install express-rate-limit
```

**Setting Up Rate Limiting:**

```javascript
const rateLimit = require('express-rate-limit');

// Create a rate limiter
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests, please try again later.',
});

// Apply to login route
app.use('/login', limiter);
```

# Complete Example with Rate Limiting and Input Validation

```javascript
const express = require('express');
const session = require('express-session');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const bcrypt = require('bcrypt');
const User = require('./models/User'); // Your User model

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(session({ secret: 'your_secret', resave: false, saveUninitialized: true }));
app.use(passport.initialize());
app.use(passport.session());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests, please try again later.',
});

app.use('/login', limiter);

// Passport configuration
passport.use(new LocalStrategy(async (username, password, done) => {
  const user = await User.findOne({ username });
  if (!user) return done(null, false, { message: 'Incorrect username.' });
  const match = await bcrypt.compare(password, user.password);
  if (!match) return done(null, false, { message: 'Incorrect password.' });
  return done(null, user);
}));

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  const user = await User.findById(id);
  done(null, user);
});

// Registration route with validation
app.post('/register', [
  body('username').notEmpty().withMessage('Username is required').isLength({ min: 3 }),
  body('password').isLength({ min: 6 }),
  body('email').isEmail(),
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  const hashedPassword = await bcrypt.hash(req.body.password, 10);
  const user = new User({ username: req.body.username, password: hashedPassword, email: req.body.email });
  await user.save();
  res.status(201).send('User registered');
});

// Login route
app.post('/login', passport.authenticate('local', {
  successRedirect: '/',
  failureRedirect: '/login',
}));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```




 -How to implement a RabbitMQ consumer in a Node.js backend, 
including code  and explanations.

A.Setting Up RabbitMQ

1. **Install RabbitMQ**: If you haven't installed RabbitMQ yet, you can follow the instructions on the [official RabbitMQ website](https://www.rabbitmq.com/download.html).

2. **Start RabbitMQ**: After installation, start the RabbitMQ server using the command:
   ```bash
   rabbitmq-server
   ```

B.Setting Up Node.js Project

1. **Create a new Node.js project**:
   ```bash
   mkdir rabbitmq-consumer
   cd rabbitmq-consumer
   npm init -y
   ```

2. **Install required packages**:
   ```bash
   npm install amqplib
   ```

C. Implementing RabbitMQ Consumer

**Create a file named `consumer.js`** and add the following code:

```javascript
const amqp = require('amqplib');

async function startConsumer() {
  try {
    // Connect to RabbitMQ server
    const connection = await amqp.connect('amqp://localhost');
    const channel = await connection.createChannel();
    
    const queue = 'myQueue'; // Name of the queue you want to consume from

    // Ensure the queue exists before consuming
    await channel.assertQueue(queue, { durable: true });

    console.log(`Waiting for messages in ${queue}. To exit press CTRL+C`);

    // Consume messages from the queue
    channel.consume(queue, (msg) => {
      if (msg !== null) {
        const messageContent = msg.content.toString();
        console.log(`Received: ${messageContent}`);

        // Acknowledge the message
        channel.ack(msg);
      }
    }, {
      noAck: false // Acknowledge messages manually
    });

  } catch (error) {
    console.error('Error in RabbitMQ consumer:', error);
  }
}

// Start the consumer
startConsumer();
```

- Explanation of the Code

1. **Connecting to RabbitMQ**: 
   - `amqp.connect('amqp://localhost')`: Connects to the RabbitMQ server running on localhost.

2. **Creating a Channel**:
   - `connection.createChannel()`: Creates a channel to communicate with RabbitMQ.

3. **Declaring a Queue**:
   - `channel.assertQueue(queue, { durable: true })`: Ensures that the queue exists. If it doesn’t, it will be created. The `durable` option makes sure the queue survives server restarts.

4. **Consuming Messages**:
   - `channel.consume(queue, callback)`: Starts consuming messages from the specified queue. The callback function processes each message received.

5. **Acknowledging Messages**:
   - `channel.ack(msg)`: Acknowledges that the message has been processed. If you don't acknowledge, the message will remain in the queue.

6. **Error Handling**: 
   - A try-catch block is used to handle any errors that may occur during connection or consumption.

-Running the Consumer

To run the consumer, execute the following command in your terminal:

```bash
node consumer.js
```

-Sending Messages to the Queue

To test the consumer, we can create a simple producer to send messages to the queue. Create a file named `producer.js`:

```javascript
const amqp = require('amqplib');

async function startProducer() {
  try {
    const connection = await amqp.connect('amqp://localhost');
    const channel = await connection.createChannel();
  
    const queue = 'myQueue';
    const message = 'Hello RabbitMQ!';

    await channel.assertQueue(queue, { durable: true });
    channel.sendToQueue(queue, Buffer.from(message), { persistent: true });

    console.log(`Sent: ${message}`);
    await channel.close();
    await connection.close();
  } catch (error) {
    console.error('Error in RabbitMQ producer:', error);
  }
}

// Start the producer
startProducer();
```

- Running the Producer

To send a message to the queue, execute the following command in your terminal:

```bash
node producer.js
'''



How to connect an Angular frontend to a Node.js backend 
and how to implement JWT authentication in our Angular app.

## 1. Connecting Angular Frontend to Node.js Backend

### Step 1: Set Up Node.js Backend

1. **Create a Simple Node.js Server**:

**Install Express and CORS**:

```bash
npm install express cors body-parser
```

**Create `server.js`**:

```javascript
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(bodyParser.json());

// Sample endpoint
app.get('/api/data', (req, res) => {
  res.json({ message: 'Hello from the backend!' });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

Step 2: Set Up Angular Project

1. **Generate a new Angular project**:

```bash
ng new my-angular-app
cd my-angular-app
ng serve --open
```

 Step 3: Create a Service to Call the API

1. **Generate a service**:

```bash
ng generate service api
```

**`api.service.ts`**:

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private apiUrl = 'http://localhost:5000/api'; // Backend URL

  constructor(private http: HttpClient) {}

  getData(): Observable<any> {
    return this.http.get(`${this.apiUrl}/data`);
  }
}
```

### Step 4: Use the Service in a Component

1. **Generate a component**:

```bash
ng generate component home
```

**`home.component.ts`**:

```typescript
import { Component, OnInit } from '@angular/core';
import { ApiService } from '../api.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
})
export class HomeComponent implements OnInit {
  data: any;

  constructor(private apiService: ApiService) {}

  ngOnInit(): void {
    this.apiService.getData().subscribe((response) => {
      this.data = response.message;
    });
  }
}
```

**`home.component.html`**:

```html
<div>
  <h1>Data from Backend:</h1>
  <p>{{ data }}</p>
</div>
```

Step 5: Update App Module

1. **Import `HttpClientModule`** in `app.module.ts`:

```typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Step 6: Display the Component

**Update `app.component.html`**:

```html
<app-home></app-home>
```

### Step 7: Run the Application

Make sure your Node.js server is running and then run the Angular app:

```bash
ng serve
```

Visit `http://localhost:4200/` in your browser to see the data fetched from the backend.

---

2. Using JWT for Authentication in the Angular App

Step 1: Set Up Node.js Backend for JWT

1. **Install JWT and bcrypt**:

```bash
npm install jsonwebtoken bcrypt
```

**Update `server.js`**:

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// Sample user for demonstration
const users = [{ id: 1, username: 'testuser', password: '$2b$10$...' }]; // Store hashed password

// Authentication endpoint
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);
  if (!user) return res.status(400).send('User not found');

  const match = await bcrypt.compare(password, user.password);
  if (!match) return res.status(400).send('Invalid password');

  const token = jwt.sign({ id: user.id }, 'your_jwt_secret', { expiresIn: '1h' });
  res.json({ token });
});
```

### Step 2: Update Angular Service for Authentication

**Update `api.service.ts`**:

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private apiUrl = 'http://localhost:5000/api';
  private token: string | null = null;

  constructor(private http: HttpClient) {}

  login(username: string, password: string): Observable<any> {
    return this.http.post(`${this.apiUrl}/login`, { username, password });
  }

  setToken(token: string) {
    this.token = token;
    localStorage.setItem('jwt', token);
  }

  getToken() {
    return localStorage.getItem('jwt');
  }

  // Example method to get data with JWT
  getData(): Observable<any> {
    const headers = { Authorization: `Bearer ${this.getToken()}` };
    return this.http.get(`${this.apiUrl}/data`, { headers });
  }
}
```

-Step 3: Create Login Component

1. **Generate a component**:

```bash
ng generate component login
```

**`login.component.ts`**:

```typescript
import { Component } from '@angular/core';
import { ApiService } from '../api.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
})
export class LoginComponent {
  username: string = '';
  password: string = '';

  constructor(private apiService: ApiService) {}

  login() {
    this.apiService.login(this.username, this.password).subscribe((response) => {
      this.apiService.setToken(response.token);
      alert('Login successful!');
    }, (error) => {
      alert('Login failed!');
    });
  }
}
```

**`login.component.html`**:

```html
<div>
  <h2>Login</h2>
  <input type="text" [(ngModel)]="username" placeholder="Username" />
  <input type="password" [(ngModel)]="password" placeholder="Password" />
  <button (click)="login()">Login</button>
</div>
```

-Step 4: Update App Module

**Update `app.module.ts`** to include `FormsModule`:

```typescript
import { FormsModule } from '@angular/forms';

@NgModule({
  imports: [
    BrowserModule,
    HttpClientModule,
    FormsModule // Add this line
  ],
})
```

-Step 5: Display Login Component

**Update `app.component.html`**:

```html
<app-login></app-login>
<app-home></app-home>
```

### Step 6: Run the Application

We make sure our Node.js server is running and then run the Angular app:

```bash
ng serve
```


4. Build and Start Using JSON Packages

To run the application:

1. **Run the Flask Application**:
   ```bash
   python app.py
   ```

2. **Add a Recipe** (via `curl`):
   ```bash
   curl -X POST http://127.0.0.1:5000/recipes -H "Content-Type: application/json" -d '{"name": "Pasta", "ingredients": ["noodles", "sauce"], "instructions": "Boil noodles and add sauce."}'
   ```

3. **Get Recipes**:
   ```bash
   curl http://127.0.0.1:5000/recipes
   ```

F. ERROR HANDLING/DEBUGGING/POSTMAN TESTING :

Certainly! Here are detailed code examples and explanations for the "Recipe Food Search App," covering API testing with Postman and cURL, console logging, error handling, and debugging tools.

### 1. Postman Testing of API Endpoints

You can use Postman to test the API endpoints for adding and retrieving recipes.

#### Steps to Test in Postman

1. **Add a Recipe (POST)**
   - **URL**: `http://127.0.0.1:5000/recipes`
   - **Method**: POST
   - **Body** (JSON):
     ```json
     {
       "name": "Pasta",
       "ingredients": ["noodles", "sauce"],
       "instructions": "Boil noodles and add sauce."
     }
     ```

2. **Get Recipes (GET)**
   - **URL**: `http://127.0.0.1:5000/recipes`
   - **Method**: GET

 2. cURL Command-Line Testing

-operations using cURL commands.

 Add a Recipe

```bash
curl -X POST http://127.0.0.1:5000/recipes -H "Content-Type: application/json" -d '{"name": "Pasta", "ingredients": ["noodles", "sauce"], "instructions": "Boil noodles and add sauce."}'
```

 Get Recipes

```bash
curl http://127.0.0.1:5000/recipes
```

3. Console Logging

You can add console logging in your Flask app to track the flow of data and catch errors. However, since Flask uses `print` for logging, here's how to do that:

#### Example Code with Logging

```python
import logging
from flask import Flask, jsonify, request
import sqlite3
import json

app = Flask(__name__)

# Set up logging
logging.basicConfig(level=logging.INFO)

def init_db():
    conn = sqlite3.connect('recipes.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS recipes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            ingredients TEXT NOT NULL,
            instructions TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

@app.route('/recipes', methods=['POST'])
def add_recipe():
    try:
        data = request.json
        logging.info(f"Received data: {data}")
        name = data['name']
        ingredients = json.dumps(data['ingredients'])
        instructions = data['instructions']
        
        conn = sqlite3.connect('recipes.db')
        cursor = conn.cursor()
        cursor.execute('INSERT INTO recipes (name, ingredients, instructions) VALUES (?, ?, ?)',
                       (name, ingredients, instructions))
        conn.commit()
        conn.close()
        
        logging.info("Recipe added successfully.")
        return jsonify({"message": "Recipe added"}), 201
    except Exception as e:
        logging.error(f"Error adding recipe: {e}")
        return jsonify({"error": "Failed to add recipe"}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    try:
        conn = sqlite3.connect('recipes.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM recipes')
        rows = cursor.fetchall()
        conn.close()
        
        recipes = [{"id": row[0], "name": row[1], "ingredients": json.loads(row[2]), "instructions": row[3]} for row in rows]
        logging.info("Fetched recipes successfully.")
        return jsonify(recipes)
    except Exception as e:
        logging.error(f"Error fetching recipes: {e}")
        return jsonify({"error": "Failed to fetch recipes"}), 500

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
```

### 4. Error Handling

In the provided code, error handling is implemented using `try-except` blocks around asynchronous operations to catch and log any errors.

### 5. Debugging Tools

#### Using `nodemon` for Hot Reloading

1. **Install nodemon** globally if you haven't already:
   ```bash
   npm install -g nodemon
   ```

2. **Run your Flask app** using nodemon:
   You can run Python scripts with nodemon by creating a script in your `package.json` or using a direct command:
   ```bash
   nodemon --exec python app.py
   ```

#### Using Debugger for Inspecting Values

You can use `pdb` for debugging Python applications. Here’s how to set it up in your code:

```python
import pdb

@app.route('/recipes', methods=['POST'])
def add_recipe():
    try:
        data = request.json
        pdb.set_trace()  # Start debugging here
        # Rest of the code...
```


 1. Integrating Webhooks

Webhooks allow our application to receive real-time data from external services. For example, you might want to receive notifications when a new recipe is added from an external API.

Example Code for Webhooks

```python
from flask import Flask, jsonify, request
import logging

app = Flask(__name__)

# Set up logging
logging.basicConfig(level=logging.INFO)

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        data = request.json
        logging.info(f"Webhook received: {data}")
        # Process the incoming data, e.g., add it to the database or notify users
        return jsonify({"status": "success"}), 200
    except Exception as e:
        logging.error(f"Error processing webhook: {e}")
        return jsonify({"error": "Failed to process webhook"}), 500

if __name__ == '__main__':
    app.run(port=5000)
```

-Testing the Webhook

You can test the webhook using Postman or cURL:

```bash
curl -X POST http://127.0.0.1:5000/webhook -H "Content-Type: application/json" -d '{"event": "new_recipe", "data": {"name": "Salad", "ingredients": ["lettuce", "tomato"], "instructions": "Mix ingredients."}}'
```

 2. Failure and Retry Framework

Implementing a failure and retry mechanism can be done using a simple loop with a try-except block. Here's how you could do that.

#### Example Code for Retry Mechanism

```python
import time

def add_recipe_with_retry(data, retries=3, delay=2):
    for attempt in range(retries):
        try:
            # Simulate adding a recipe
            add_recipe_to_db(data)  # Assume this function adds to the database
            logging.info("Recipe added successfully.")
            return {"status": "success"}
        except Exception as e:
            logging.error(f"Attempt {attempt + 1}: Failed to add recipe: {e}")
            if attempt < retries - 1:
                time.sleep(delay)  # Wait before retrying
    return {"status": "failure", "error": "Max retries exceeded"}

def add_recipe_to_db(data):
    # Simulated database operation
    raise Exception("Simulated database error")  # Simulating a failure
```

3. Monitoring and Logging with Grafana and Prometheus

- Setting Up Prometheus

1. **Install Prometheus** on your server or local machine. You can follow the [Prometheus installation guide](https://prometheus.io/docs/prometheus/latest/installation/).

2. **Create a configuration file** (`prometheus.yml`):

```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'flask_app'
    static_configs:
      - targets: ['localhost:5000']
```

3. **Expose Metrics from Flask**:

You need to expose metrics from your Flask application. You can use the `prometheus_client` library.

```bash
pip install prometheus_client
```

 Modify Your Flask App to Expose Metrics

```python
from prometheus_client import start_http_server, Counter

# Create a counter for tracking recipe additions
recipe_counter = Counter('recipes_added', 'Number of recipes added')

@app.route('/recipes', methods=['POST'])
def add_recipe():
    try:
        data = request.json
        # Add to database logic here...
        recipe_counter.inc()  # Increment the counter
        return jsonify({"message": "Recipe added"}), 201
    except Exception as e:
        logging.error(f"Error adding recipe: {e}")
        return jsonify({"error": "Failed to add recipe"}), 500

if __name__ == '__main__':
    start_http_server(8000)  # Start Prometheus metrics server
    app.run(port=5000)
```

 Setting Up Grafana

1. **Install Grafana** on your server or local machine. Follow the [Grafana installation guide](https://grafana.com/docs/grafana/latest/installation/).

2. **Add Prometheus as a Data Source in Grafana**:
   - Go to Grafana, log in, and navigate to "Configuration" > "Data Sources".
   - Add Prometheus and set the URL to `http://localhost:9090` (or where your Prometheus server is running).

3. **Create Dashboards**:
   - You can create dashboards in Grafana to visualize the metrics from your Flask app, such as the number of recipes added over time.



 1. Setup and Install JSON Packages

Step 1: Create a Virtual Environment

```bash
- Create a virtual environment
python -m venv venv
# Activate the virtual environment
source venv/bin/activate  # On Windows use `venv\Scripts\activate`
```

#### Step 2: Install Required Packages

You will need Flask for the web framework and a few other packages if required. In this case, the built-in `json` module is sufficient for handling JSON data.

Create a `requirements.txt` file:

```plaintext
Flask
```

Then install the dependencies:

```bash
pip install -r requirements.txt
```

### 2. Build the Application

-Code for `app.py`

Here’s the complete code for your Recipe Food Search App that uses JSON for data handling:

```python
from flask import Flask, jsonify, request
import sqlite3
import json

app = Flask(__name__)

# Initialize SQLite database
def init_db():
    conn = sqlite3.connect('recipes.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS recipes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            ingredients TEXT NOT NULL,
            instructions TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

@app.route('/recipes', methods=['POST'])
def add_recipe():
    try:
        data = request.json
        name = data['name']
        ingredients = json.dumps(data['ingredients'])
        instructions = data['instructions']
        
        conn = sqlite3.connect('recipes.db')
        cursor = conn.cursor()
        cursor.execute('INSERT INTO recipes (name, ingredients, instructions) VALUES (?, ?, ?)',
                       (name, ingredients, instructions))
        conn.commit()
        conn.close()
        
        return jsonify({"message": "Recipe added"}), 201
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    try:
        conn = sqlite3.connect('recipes.db')
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM recipes')
        rows = cursor.fetchall()
        conn.close()
        
        recipes = [{"id": row[0], "name": row[1], "ingredients": json.loads(row[2]), "instructions": row[3]} for row in rows]
        return jsonify(recipes)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
```

 3. Start the Application

To run our application, use the following command:

```bash
python app.py
```

### 4. Testing the Endpoints

Once the application is running, you can test the API endpoints using Postman or cURL.

#### Add a Recipe (POST)

Using cURL:

```bash
curl -X POST http://127.0.0.1:5000/recipes -H "Content-Type: application/json" -d '{"name": "Pasta", "ingredients": ["noodles", "sauce"], "instructions": "Boil noodles and add sauce."}'
```

#### Get Recipes (GET)

Using cURL:

```bash
curl http://127.0.0.1:5000/recipes
```




                       ADVANTAGES/BENEFITS
                     Advantages of a Food Search Recipe App in Vue.js and API
- Reactive and Efficient: Vue.js is known for its reactivity system, which efficiently updates the DOM when the state of the application changes. This makes it ideal for dynamic applications like a food search recipe app.
- Component-Based Architecture: Vue.js's component-based architecture allows for the creation of reusable UI components, making it easier to maintain and update the app.
- Easy Integration with APIs: Vue.js can easily integrate with APIs, allowing you to fetch and display recipe data from various sources.
- Large Ecosystem: Vue.js has a large and growing ecosystem of tools and libraries, making it easier to find solutions to common problems.
- Flexible and Adaptable: Vue.js is flexible and adaptable, allowing you to build a wide range of applications, from small prototypes to large-scale enterprise applications.
- API Advantages
- Access to Large Recipe Database: By integrating with a recipe API, 
you can access a large database of recipes, providing users with 
a wide range of options.
- Real-Time Data: APIs can provide real-time data, allowing users to
access the latest recipe information.

5).COMMON PITFALLS/PROBLEMS/DISADVANTAGES:

-Disadvantages of a Food Search Recipe App in Vue.js and API
- Smaller Community Compared to React and Angular: Although Vue.js has a growing community, it still lags behind React and Angular in terms of community size and support.
- Limited Support for Large-Scale Applications: While Vue.js can handle large-scale applications, it may require additional setup and configuration to ensure optimal performance.
- API Limitations: The app's functionality is dependent on the API's capabilities and limitations. If the API is not well-documented or has usage limits, it may impact the app's performance.

                           API Disadvantages
- API Rate Limits: Many APIs have rate limits, which can impact the 
app's performance if not handled properly, .This is a common neccessity in a world of massive ' cyberattacks' wth the malicous intent to either destroy 
or control what others have or exploit them for pecunuary gain.
- Data Quality Issues: The quality of the recipe data provided by the API can impact the user experience.

                     Real-Life Examples
- Yummly: A popular recipe discovery platform that uses APIs to aggregate 
recipe data from various sources.

- Allrecipes: A well-known cooking website that provides a large 
database of recipes and cooking information.


6.)CONCLUSION :
The saying' you are what you eat ' is very apt here, as worldwide an epidemic of ' obesity is on-going ' and people are constantly looking for ' recepies 
of food to help them reduce, weight, fight cholesterol,look younger , and delay 
the inevitable consequencies of Aging, and delay death.
hence, the need and search for more , and more Recipes, foods to arcieve the above needs of mankind.
Hence, our APP will fullfill all these expectations!


























5).COMMON PITFALLS/PROBLEMS:







